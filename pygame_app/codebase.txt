"""
pygame_app/src/audio_engine.py
Enhanced Spatial Audio Engine
Advanced audio synthesis and real-time mixing for spatial audio applications
"""

import pygame
import numpy as np
import threading
import time
import os
import queue
from typing import Dict, List, Optional, Tuple, Callable, Any
from dataclasses import dataclass
from enum import Enum
import wave
import json

class AudioFileType(Enum):
    SINE_WAVE = "sine_wave"
    AUDIO_FILE = "audio_file"
    SYNTHESIZED = "synthesized"

@dataclass
class AudioSource:
    """Represents an audio source that can be assigned to devices"""
    id: str
    name: str
    file_type: AudioFileType
    file_path: Optional[str] = None
    frequency: Optional[float] = None
    waveform: Optional[np.ndarray] = None

@dataclass
class AudioChannel:
    """Represents an active audio channel for a device"""
    device_id: str
    audio_source: AudioSource
    current_volume: float
    current_frequency: float
    is_playing: bool
    last_update: float
    is_enabled: bool = True

class SpatialAudioEngine:
    """Enhanced spatial audio synthesis engine with real-time mixing"""
    
    def __init__(self):
        """Initialize the enhanced audio engine"""
        self.channels: Dict[str, AudioChannel] = {}
        self.audio_sources: Dict[str, AudioSource] = {}
        self.master_volume = 0.75
        self.enabled = True
        self.sample_rate = 44100
        self.buffer_size = 1024
        
        # Real-time audio mixing
        self.mixing_enabled = True
        self.mixed_audio_queue = queue.Queue(maxsize=10)
        self.audio_thread = None
        self.mixing_thread = None
        self.running = False
        
        # Audio processing parameters
        self.fade_duration = 0.01  # 10ms fade to prevent clicks
        self.max_concurrent_sounds = 8
        
        # Initialize pygame mixer with optimal settings
        try:
            pygame.mixer.quit()  # Ensure clean state
            pygame.mixer.init(
                frequency=self.sample_rate,
                size=-16,  # 16-bit signed
                channels=2,  # Stereo
                buffer=self.buffer_size
            )
            print(f"Audio engine initialized: {self.sample_rate}Hz, {self.buffer_size} buffer")
        except Exception as e:
            print(f"Audio initialization error: {e}")
            # Fallback initialization
            pygame.mixer.init()
            
        # Create default audio sources
        self._create_default_sources()
        
        # Start real-time audio processing
        self._start_audio_processing()
        
        print("Enhanced Spatial Audio Engine initialized")
        
    def _create_default_sources(self):
        """Create default sine wave audio sources with better variety"""
        # Musical frequencies
        musical_sources = [
            (220.0, "A3 - Low Tone"),
            (261.63, "C4 - Middle C"),
            (329.63, "E4 - Major Third"),
            (440.0, "A4 - Concert Pitch"),
            (523.25, "C5 - High C"),
            (659.25, "E5 - High E"),
            (880.0, "A5 - High A"),
            (1000.0, "B5 - Pure Tone")
        ]
        
        for freq, name in musical_sources:
            source_id = f"sine_{int(freq)}"
            self.audio_sources[source_id] = AudioSource(
                id=source_id,
                name=name,
                file_type=AudioFileType.SINE_WAVE,
                frequency=freq
            )
        
        # Add special waveforms
        self._create_special_waveforms()
            
    def _create_special_waveforms(self):
        """Create special synthesized waveforms"""
        special_sources = [
            ("square_440", "Square Wave (440Hz)", self._generate_square_wave, 440.0),
            ("sawtooth_440", "Sawtooth Wave (440Hz)", self._generate_sawtooth_wave, 440.0),
            ("triangle_440", "Triangle Wave (440Hz)", self._generate_triangle_wave, 440.0),
            ("pulse_440", "Pulse Wave (440Hz)", self._generate_pulse_wave, 440.0)
        ]
        
        for source_id, name, generator, freq in special_sources:
            waveform = generator(freq, 1.0)  # 1 second sample
            self.audio_sources[source_id] = AudioSource(
                id=source_id,
                name=name,
                file_type=AudioFileType.SYNTHESIZED,
                frequency=freq,
                waveform=waveform
            )
    
    def _generate_square_wave(self, frequency: float, duration: float) -> np.ndarray:
        """Generate a square wave"""
        samples = int(self.sample_rate * duration)
        t = np.linspace(0, duration, samples, False)
        return np.sign(np.sin(2 * np.pi * frequency * t))
    
    def _generate_sawtooth_wave(self, frequency: float, duration: float) -> np.ndarray:
        """Generate a sawtooth wave"""
        samples = int(self.sample_rate * duration)
        t = np.linspace(0, duration, samples, False)
        return 2 * (t * frequency - np.floor(t * frequency + 0.5))
    
    def _generate_triangle_wave(self, frequency: float, duration: float) -> np.ndarray:
        """Generate a triangle wave"""
        samples = int(self.sample_rate * duration)
        t = np.linspace(0, duration, samples, False)
        return 2 * np.abs(2 * (t * frequency - np.floor(t * frequency + 0.5))) - 1
    
    def _generate_pulse_wave(self, frequency: float, duration: float, duty_cycle: float = 0.3) -> np.ndarray:
        """Generate a pulse wave with adjustable duty cycle"""
        samples = int(self.sample_rate * duration)
        t = np.linspace(0, duration, samples, False)
        phase = (t * frequency) % 1
        return np.where(phase < duty_cycle, 1.0, -1.0)
        
    def _start_audio_processing(self):
        """Start the real-time audio processing threads"""
        if self.running:
            return
            
        self.running = True
        
        # Start mixing thread
        self.mixing_thread = threading.Thread(target=self._mixing_worker, daemon=True)
        self.mixing_thread.start()
        
        print("Real-time audio processing started")
        
    def _mixing_worker(self):
        """Real-time audio mixing worker thread"""
        while self.running:
            try:
                if self.mixing_enabled and self.channels:
                    self._process_active_channels()
                time.sleep(0.05)  # 20Hz update rate for smooth mixing
            except Exception as e:
                print(f"Mixing worker error: {e}")
                
    def _process_active_channels(self):
        """Process and mix active audio channels"""
        current_time = time.time()
        active_channels = []
        
        # Get currently active channels
        for channel in self.channels.values():
            if (channel.is_enabled and 
                current_time - channel.last_update < 0.5 and  # Active within 500ms
                channel.current_volume > 0.01):  # Audible volume
                active_channels.append(channel)
        
        if not active_channels:
            return
            
        # Limit concurrent sounds for performance
        if len(active_channels) > self.max_concurrent_sounds:
            # Sort by volume and take the loudest ones
            active_channels.sort(key=lambda c: c.current_volume, reverse=True)
            active_channels = active_channels[:self.max_concurrent_sounds]
        
        # Generate mixed audio for active channels
        self._generate_mixed_audio(active_channels)
    
    def _generate_mixed_audio(self, channels: List[AudioChannel]):
        """Generate and mix audio from multiple channels"""
        if not channels:
            return
            
        try:
            duration = 0.1  # 100ms chunks for smooth playback
            samples = int(self.sample_rate * duration)
            mixed_audio = np.zeros((samples, 2), dtype=np.float32)
            
            for channel in channels:
                if not channel.is_enabled:
                    continue
                    
                # Generate audio for this channel
                channel_audio = self._generate_channel_audio(channel, duration)
                if channel_audio is not None:
                    # Apply volume and add to mix
                    volume = channel.current_volume * self.master_volume
                    volume = max(0.0, min(1.0, volume))  # Clamp volume
                    
                    # Ensure stereo format
                    if len(channel_audio.shape) == 1:
                        stereo_audio = np.column_stack((channel_audio, channel_audio))
                    else:
                        stereo_audio = channel_audio
                    
                    # Add to mixed audio with volume control
                    if stereo_audio.shape[0] == samples:
                        mixed_audio += stereo_audio * volume
            
            # Normalize to prevent clipping
            max_amplitude = np.max(np.abs(mixed_audio))
            if max_amplitude > 0.95:
                mixed_audio *= 0.95 / max_amplitude
            
            # Convert to 16-bit and play
            mixed_audio_16bit = (mixed_audio * 32767).astype(np.int16)
            
            # Play the mixed audio
            if not pygame.mixer.get_busy() or pygame.mixer.get_num_channels() < 4:
                try:
                    sound = pygame.sndarray.make_sound(mixed_audio_16bit)
                    sound.play()
                except Exception as e:
                    print(f"Audio playback error: {e}")
                    
        except Exception as e:
            print(f"Mixed audio generation error: {e}")
    
    def _generate_channel_audio(self, channel: AudioChannel, duration: float) -> Optional[np.ndarray]:
        """Generate audio for a specific channel"""
        try:
            audio_source = channel.audio_source
            frequency = channel.current_frequency
            
            if audio_source.file_type == AudioFileType.SINE_WAVE:
                return self._generate_sine_wave_audio(frequency, duration)
            elif audio_source.file_type == AudioFileType.SYNTHESIZED:
                return self._generate_synthesized_audio(audio_source, frequency, duration)
            elif audio_source.file_type == AudioFileType.AUDIO_FILE:
                return self._generate_file_audio(audio_source, duration)
                
        except Exception as e:
            print(f"Channel audio generation error: {e}")
            return None
    
    def _generate_sine_wave_audio(self, frequency: float, duration: float) -> np.ndarray:
        """Generate sine wave audio"""
        samples = int(self.sample_rate * duration)
        t = np.linspace(0, duration, samples, False)
        wave_data = np.sin(2 * np.pi * frequency * t)
        
        # Apply fade envelope
        envelope_samples = int(self.fade_duration * self.sample_rate)
        if samples > 2 * envelope_samples:
            # Fade in
            wave_data[:envelope_samples] *= np.linspace(0, 1, envelope_samples)
            # Fade out
            wave_data[-envelope_samples:] *= np.linspace(1, 0, envelope_samples)
        
        return wave_data
    
    def _generate_synthesized_audio(self, audio_source: AudioSource, frequency: float, duration: float) -> np.ndarray:
        """Generate audio from synthesized waveforms"""
        if audio_source.waveform is None:
            return self._generate_sine_wave_audio(frequency, duration)
        
        # Use the pre-generated waveform, scaled to the requested frequency
        base_frequency = audio_source.frequency or 440.0
        frequency_ratio = frequency / base_frequency
        
        # Resample the waveform for the new frequency
        samples = int(self.sample_rate * duration)
        waveform_samples = len(audio_source.waveform)
        
        # Simple resampling by adjusting playback speed
        indices = np.arange(samples) * frequency_ratio * waveform_samples / samples
        indices = indices.astype(int) % waveform_samples
        
        wave_data = audio_source.waveform[indices]
        
        # Apply fade envelope
        envelope_samples = int(self.fade_duration * self.sample_rate)
        if samples > 2 * envelope_samples:
            wave_data[:envelope_samples] *= np.linspace(0, 1, envelope_samples)
            wave_data[-envelope_samples:] *= np.linspace(1, 0, envelope_samples)
        
        return wave_data
    
    def _generate_file_audio(self, audio_source: AudioSource, duration: float) -> Optional[np.ndarray]:
        """Generate audio from file source"""
        if not audio_source.file_path or not os.path.exists(audio_source.file_path):
            return None
        
        try:
            # Load audio file (simplified - in practice, you'd want more robust loading)
            sound = pygame.mixer.Sound(audio_source.file_path)
            # For now, fall back to sine wave
            return self._generate_sine_wave_audio(440.0, duration)
        except Exception as e:
            print(f"File audio generation error: {e}")
            return None
            
    def register_audio_file(self, file_name: str, file_path: str) -> str:
        """Register a new audio file"""
        source_id = f"file_{len(self.audio_sources)}"
        
        self.audio_sources[source_id] = AudioSource(
            id=source_id,
            name=file_name,
            file_type=AudioFileType.AUDIO_FILE,
            file_path=file_path
        )
        
        print(f"Registered audio file: {file_name}")
        return source_id
        
    def get_audio_sources(self) -> List[AudioSource]:
        """Get list of all available audio sources"""
        return list(self.audio_sources.values())
        
    def synthesize_audio(self, device_id: str, frequency: float, volume: float, 
                        audio_file: Optional[str] = None, duration: float = 0.5):
        """Synthesize audio for a specific device with enhanced real-time mixing"""
        if not self.enabled:
            return
            
        try:
            # Get or create audio channel
            if device_id not in self.channels:
                # Default to first sine wave if no audio file specified
                source_id = audio_file or "sine_440"
                audio_source = self.audio_sources.get(source_id)
                
                if not audio_source:
                    print(f"Audio source not found: {source_id}, using default")
                    audio_source = list(self.audio_sources.values())[0]
                    
                self.channels[device_id] = AudioChannel(
                    device_id=device_id,
                    audio_source=audio_source,
                    current_volume=volume,
                    current_frequency=frequency,
                    is_playing=False,
                    last_update=time.time(),
                    is_enabled=True
                )
                
            channel = self.channels[device_id]
            
            # Update channel parameters
            channel.current_volume = volume
            channel.current_frequency = frequency
            channel.last_update = time.time()
            channel.is_playing = True
            
            # If real-time mixing is disabled, play individual sounds
            if not self.mixing_enabled:
                self._play_individual_sound(channel, duration)
                
        except Exception as e:
            print(f"Audio synthesis error: {e}")
    
    def _play_individual_sound(self, channel: AudioChannel, duration: float):
        """Play individual sound for a channel (fallback mode)"""
        try:
            audio_data = self._generate_channel_audio(channel, duration)
            if audio_data is not None:
                # Apply volume
                volume = min(1.0, max(0.0, channel.current_volume * self.master_volume))
                audio_data = audio_data * volume
                
                # Convert to 16-bit integers
                audio_data = (audio_data * 32767).astype(np.int16)
                
                # Create stereo sound
                if len(audio_data.shape) == 1:
                    stereo_wave = np.column_stack((audio_data, audio_data))
                else:
                    stereo_wave = audio_data
                
                # Create pygame sound and play
                sound = pygame.sndarray.make_sound(stereo_wave)
                sound.play()
                
        except Exception as e:
            print(f"Individual sound playback error: {e}")
            
    def assign_audio_to_device(self, device_id: str, audio_source_id: str):
        """Assign an audio source to a device"""
        audio_source = self.audio_sources.get(audio_source_id)
        if not audio_source:
            print(f"Audio source not found: {audio_source_id}")
            return False
            
        if device_id in self.channels:
            self.channels[device_id].audio_source = audio_source
        else:
            self.channels[device_id] = AudioChannel(
                device_id=device_id,
                audio_source=audio_source,
                current_volume=0.5,
                current_frequency=audio_source.frequency or 440.0,
                is_playing=False,
                last_update=time.time(),
                is_enabled=True
            )
            
        print(f"Assigned {audio_source.name} to device {device_id}")
        return True
    
    def enable_device_audio(self, device_id: str, enabled: bool):
        """Enable or disable audio for a specific device"""
        if device_id in self.channels:
            self.channels[device_id].is_enabled = enabled
            status = "enabled" if enabled else "disabled"
            print(f"Device {device_id} audio {status}")
        
    def get_device_audio_source(self, device_id: str) -> Optional[AudioSource]:
        """Get the audio source assigned to a device"""
        channel = self.channels.get(device_id)
        return channel.audio_source if channel else None
        
    def set_master_volume(self, volume: float):
        """Set master volume (0.0 to 1.0)"""
        self.master_volume = max(0.0, min(1.0, volume))
        pygame.mixer.music.set_volume(self.master_volume)
        print(f"Master volume set to {self.master_volume:.1%}")
        
    def set_mixing_enabled(self, enabled: bool):
        """Enable or disable real-time audio mixing"""
        self.mixing_enabled = enabled
        status = "enabled" if enabled else "disabled"
        print(f"Real-time audio mixing {status}")
        
    def enable(self):
        """Enable audio synthesis"""
        self.enabled = True
        print("Audio synthesis enabled")
        
    def disable(self):
        """Disable audio synthesis"""
        self.enabled = False
        # Stop all currently playing sounds
        pygame.mixer.stop()
        print("Audio synthesis disabled")
        
    def get_active_channels(self) -> List[AudioChannel]:
        """Get list of active audio channels"""
        current_time = time.time()
        active_channels = []
        
        for channel in self.channels.values():
            if (channel.is_enabled and 
                current_time - channel.last_update < 5.0):  # Active within 5 seconds
                active_channels.append(channel)
                
        return active_channels
    
    def get_enabled_channels(self) -> List[AudioChannel]:
        """Get list of enabled audio channels"""
        return [channel for channel in self.channels.values() if channel.is_enabled]
        
    def generate_test_tone(self, frequency: float = 440.0, volume: float = 0.5, duration: float = 1.0) -> bool:
        """Generate a test tone for system verification"""
        try:
            print(f"Generating test tone: {frequency}Hz, volume: {volume:.1%}, duration: {duration}s")
            
            # Generate test tone
            samples = int(self.sample_rate * duration)
            t = np.linspace(0, duration, samples, False)
            wave_data = np.sin(2 * np.pi * frequency * t) * volume
            
            # Apply envelope
            envelope_samples = int(0.05 * self.sample_rate)  # 50ms envelope
            if samples > 2 * envelope_samples:
                wave_data[:envelope_samples] *= np.linspace(0, 1, envelope_samples)
                wave_data[-envelope_samples:] *= np.linspace(1, 0, envelope_samples)
            
            # Convert to 16-bit
            wave_data = (wave_data * 32767).astype(np.int16)
            stereo_wave = np.column_stack((wave_data, wave_data))
            
            # Play sound
            sound = pygame.sndarray.make_sound(stereo_wave)
            sound.play()
            
            print("Test tone playback initiated")
            return True
            
        except Exception as e:
            print(f"Test tone generation failed: {e}")
            return False
    
    def get_engine_stats(self) -> Dict[str, Any]:
        """Get engine statistics for monitoring"""
        current_time = time.time()
        
        stats = {
            'total_channels': len(self.channels),
            'active_channels': len(self.get_active_channels()),
            'enabled_channels': len(self.get_enabled_channels()),
            'master_volume': self.master_volume,
            'mixing_enabled': self.mixing_enabled,
            'audio_sources': len(self.audio_sources),
            'sample_rate': self.sample_rate,
            'buffer_size': self.buffer_size
        }
        
        return stats
            
    def update(self, dt: float):
        """Update audio engine state"""
        # Clean up inactive channels
        current_time = time.time()
        inactive_devices = []
        
        for device_id, channel in self.channels.items():
            if current_time - channel.last_update > 30.0:  # 30 seconds timeout
                inactive_devices.append(device_id)
                
        for device_id in inactive_devices:
            del self.channels[device_id]
            print(f"Cleaned up inactive channel: {device_id}")
            
    def cleanup(self):
        """Clean up audio engine resources"""
        print("Cleaning up audio engine...")
        self.running = False
        self.enabled = False
        
        # Wait for threads to finish
        if self.mixing_thread and self.mixing_thread.is_alive():
            self.mixing_thread.join(timeout=1.0)
        
        # Stop all audio
        pygame.mixer.stop()
        pygame.mixer.quit()
        
        print("Audio engine cleanup complete")"""
pygame_app/src/config.py
Configuration settings for the Spatial Audio System
"""

class Config:
    """Application configuration constants"""
    
    # Window settings
    WINDOW_WIDTH = 1400
    WINDOW_HEIGHT = 900
    TARGET_FPS = 60
    
    # Audio settings
    AUDIO_SAMPLE_RATE = 44100
    AUDIO_BUFFER_SIZE = 1024
    AUDIO_CHANNELS = 2
    
    # Elegant color scheme (no emojis, elegant design)
    COLORS = {
        # Primary colors
        'background': (15, 15, 20),           # Very dark blue-gray
        'surface': (25, 30, 40),              # Dark surface
        'surface_light': (35, 42, 55),        # Lighter surface
        'surface_hover': (45, 52, 65),        # Hover state
        'panel_bg': (30, 35, 45),             # Panel background
        
        # Accent colors
        'primary': (70, 130, 200),            # Elegant blue
        'primary_dark': (50, 100, 160),       # Darker blue
        'secondary': (120, 180, 80),          # Elegant green
        'accent': (200, 150, 80),             # Warm accent
        
        # Text colors
        'text_primary': (240, 245, 250),      # Light text
        'text_secondary': (180, 190, 200),    # Secondary text
        'text_muted': (140, 150, 160),        # Muted text
        
        # Status colors
        'success': (80, 180, 120),            # Success green
        'warning': (220, 180, 80),            # Warning amber
        'error': (220, 80, 80),               # Error red
        'info': (80, 150, 220),               # Info blue
        
        # UI elements
        'border': (60, 70, 85),               # Border color
        'border_light': (80, 90, 105),        # Light border
        'shadow': (0, 0, 0, 50),              # Shadow color
        
        # Chart colors (for device visualization)
        'chart_colors': [
            (70, 130, 200),   # Blue
            (120, 180, 80),   # Green
            (200, 150, 80),   # Orange
            (180, 80, 180),   # Purple
            (80, 180, 180),   # Cyan
            (200, 80, 120),   # Pink
            (150, 200, 80),   # Lime
            (200, 120, 80),   # Coral
        ]
    }
    
    # Typography
    FONTS = {
        'title': ('Segoe UI', 28),
        'subtitle': ('Segoe UI', 20),
        'heading': ('Segoe UI', 16),
        'body': ('Segoe UI', 14),
        'caption': ('Segoe UI', 12),
        'small': ('Segoe UI', 10)
    }
    
    # Layout settings
    LAYOUT = {
        'padding': 20,
        'margin': 10,
        'border_radius': 8,
        'card_spacing': 15,
        'section_spacing': 25,
        'button_height': 36,
        'input_height': 32,
        'sidebar_width': 320,
        'header_height': 60
    }
    
    # Animation settings
    ANIMATION = {
        'duration_fast': 0.15,
        'duration_normal': 0.25,
        'duration_slow': 0.4,
        'easing': 'ease_out'
    }
    
    # Device settings
    DEVICE = {
        'scan_timeout': 30,     # seconds
        'connection_timeout': 10,
        'max_devices': 8,
        'demo_cycle_duration': 30,  # seconds
        'distance_update_rate': 2,  # Hz
    }
    
    # Audio processing
    AUDIO_PROCESSING = {
        'min_frequency': 200,
        'max_frequency': 1000,
        'default_volume': 75,
        'volume_smoothing': 0.1,
        'synthesis_quality': 'high'
    }
    
    # UI states
    UI_STATES = {
        'collapsed_height': 40,
        'expanded_min_height': 120,
        'button_padding': 8,
        'slider_width': 200,
        'dropdown_width': 180
    }
    
    @classmethod
    def get_chart_color(cls, index: int) -> tuple:
        """Get chart color by index (cycles through available colors)"""
        colors = cls.COLORS['chart_colors']
        return colors[index % len(colors)]
    
    @classmethod
    def get_font(cls, font_type: str) -> tuple:
        """Get font configuration by type"""
        return cls.FONTS.get(font_type, cls.FONTS['body'])
    
    @classmethod
    def get_color_with_alpha(cls, color_name: str, alpha: int) -> tuple:
        """Get color with alpha channel"""
        color = cls.COLORS.get(color_name, (255, 255, 255))
        if len(color) == 3:
            return (*color, alpha)
        return color
"""
pygame_app/src/device_manager.py
Enhanced Device Manager with Modern Bluetooth Support
Uses bleak for reliable cross-platform Bluetooth connectivity
"""

import threading
import time
import random
import math
import socket
import asyncio
import json
from typing import Dict, List, Optional, Callable, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import serial
import serial.tools.list_ports
from serial.tools.list_ports_common import ListPortInfo

# Modern Bluetooth support with bleak (recommended)
BLUETOOTH_AVAILABLE = False
BLUETOOTH_LIBRARY = None

try:
    import bleak
    from bleak import BleakScanner, BleakClient
    BLUETOOTH_AVAILABLE = True
    BLUETOOTH_LIBRARY = "bleak"
    print("‚úÖ Using 'bleak' for modern Bluetooth support")
except ImportError:
    # Fallback to pybluez (legacy)
    try:
        import bluetooth
        BLUETOOTH_AVAILABLE = True
        BLUETOOTH_LIBRARY = "pybluez"
        print("‚ö†Ô∏è  Using 'pybluez' for legacy Bluetooth support")
        print("   Consider upgrading to 'bleak' for better compatibility")
    except ImportError:
        print("‚ùå No Bluetooth library available")
        print("   Install with: pip install bleak")
        print("   Alternative: pip install pybluez")

class DeviceStatus(Enum):
    DISCONNECTED = "disconnected"
    SCANNING = "scanning"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"

@dataclass
class Device:
    """Represents a connected or discovered device"""
    device_id: str
    device_name: str
    status: DeviceStatus
    last_distance: float = 0.0
    last_update: float = 0.0
    audio_file: Optional[str] = None
    connection_time: float = 0.0
    error_message: Optional[str] = None
    connection_info: Optional[Any] = None
    device_type: str = "unknown"  # "bluetooth", "serial", "demo"
    rssi: Optional[int] = None  # Signal strength
    manufacturer_data: Optional[Dict] = None

class BluetoothDeviceInfo:
    """Container for Bluetooth device information with bleak compatibility"""
    def __init__(self, address: str, name: str, rssi: int = 0, manufacturer_data: Dict = None):
        self.address = address
        self.name = name if name else f"Device-{address[-5:].replace(':', '')}"
        self.rssi = rssi
        self.manufacturer_data = manufacturer_data or {}
        self.device = address  # For compatibility
        self.description = f"Bluetooth BLE Device - {self.name}"
        self.is_bluetooth = True

class ModernDeviceManager:
    """Enhanced Device Manager with Modern Bluetooth Support using bleak"""
    
    def __init__(self):
        self.devices: Dict[str, Device] = {}
        self.demo_device: Optional[Device] = None
        self.demo_mode = False
        self.scanning = False
        
        # Callbacks
        self.on_device_connected: Optional[Callable[[str, str], None]] = None
        self.on_device_disconnected: Optional[Callable[[str], None]] = None
        self.on_distance_update: Optional[Callable[[str, float], None]] = None
        
        # Threading
        self.running = True
        self.bluetooth_clients: Dict[str, Any] = {}  # Store active BLE clients
        
        # Bluetooth status
        self.bluetooth_available = BLUETOOTH_AVAILABLE
        self.bluetooth_library = BLUETOOTH_LIBRARY
        
        # Event loop for async operations
        self._setup_async_loop()
        
        print(f"‚úÖ Modern Device Manager initialized")
        print(f"üì∂ Bluetooth support: {'Available' if BLUETOOTH_AVAILABLE else 'Not available'}")
        if BLUETOOTH_AVAILABLE:
            print(f"üìö Using library: {BLUETOOTH_LIBRARY}")

    def _setup_async_loop(self):
        """Setup asyncio event loop for Bluetooth operations"""
        try:
            # Create a new event loop for this thread
            self.loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.loop)
            
            # Start the event loop in a separate thread
            self.async_thread = threading.Thread(target=self._run_async_loop, daemon=True)
            self.async_thread.start()
            
            print("‚úÖ Async event loop initialized for Bluetooth operations")
        except Exception as e:
            print(f"‚ö†Ô∏è  Async loop setup failed: {e}")
            self.loop = None

    def _run_async_loop(self):
        """Run the asyncio event loop"""
        if self.loop:
            self.loop.run_forever()

    def get_bluetooth_status(self) -> Dict[str, Any]:
        """Get detailed Bluetooth status information"""
        return {
            'available': self.bluetooth_available,
            'library': self.bluetooth_library,
            'can_scan': self.bluetooth_available,
            'modern_support': self.bluetooth_library == "bleak",
            'async_support': self.loop is not None
        }

    async def _scan_bluetooth_devices_async(self) -> List[BluetoothDeviceInfo]:
        """Async Bluetooth device scanning using bleak"""
        if not BLUETOOTH_AVAILABLE or BLUETOOTH_LIBRARY != "bleak":
            return []
        
        try:
            print("üîç Scanning for Bluetooth BLE devices...")
            
            # Scan for devices (10 second timeout)
            devices = await BleakScanner.discover(timeout=10.0)
            
            bluetooth_devices = []
            target_keywords = [
                'hc-05', 'hc05', 'hc-06', 'hc06', 'esp32', 'arduino', 
                'sensor', 'node', 'ble', 'bt_', 'bluetooth', 'car',
                'audio', 'distance', 'ultrasonic', 'linvor'
            ]
            
            for device in devices:
                device_name = device.name or f"Unknown-{device.address[-5:].replace(':', '')}"
                
                # Check if device matches our target patterns
                is_target_device = any(
                    keyword in device_name.lower() 
                    for keyword in target_keywords
                )
                
                # Also include devices with strong signal (likely nearby)
                is_nearby = device.rssi and device.rssi > -70
                
                if is_target_device or is_nearby:
                    bt_device = BluetoothDeviceInfo(
                        address=device.address,
                        name=device_name,
                        rssi=device.rssi or 0,
                        manufacturer_data=device.metadata.get('manufacturer_data', {})
                    )
                    bluetooth_devices.append(bt_device)
                    
                    print(f"üì± Found device: {device_name} ({device.address}) RSSI: {device.rssi}dBm")
            
            print(f"‚úÖ Bluetooth scan complete. Found {len(bluetooth_devices)} target devices")
            return bluetooth_devices
            
        except Exception as e:
            print(f"‚ùå Bluetooth scan error: {e}")
            return []

    def scan_bluetooth_devices(self) -> List[BluetoothDeviceInfo]:
        """Scan for Bluetooth devices (blocking call that uses async internally)"""
        if not self.bluetooth_available:
            print("‚ùå Bluetooth not available")
            return []
        
        if self.scanning:
            print("‚ö†Ô∏è  Already scanning...")
            return []
        
        self.scanning = True
        
        try:
            if BLUETOOTH_LIBRARY == "bleak" and self.loop:
                # Use modern bleak scanning
                future = asyncio.run_coroutine_threadsafe(
                    self._scan_bluetooth_devices_async(), self.loop
                )
                devices = future.result(timeout=15.0)  # 15 second timeout
                return devices
            
            elif BLUETOOTH_LIBRARY == "pybluez":
                # Fallback to pybluez
                return self._scan_pybluez_devices()
            
            else:
                print("‚ùå No compatible Bluetooth library available")
                return []
                
        except Exception as e:
            print(f"‚ùå Bluetooth scanning failed: {e}")
            return []
        finally:
            self.scanning = False

    def _scan_pybluez_devices(self) -> List[BluetoothDeviceInfo]:
        """Fallback scanning using pybluez"""
        try:
            import bluetooth
            print("üîç Scanning using PyBluez (legacy mode)...")
            
            nearby_devices = bluetooth.discover_devices(
                duration=8, lookup_names=True, flush_cache=True
            )
            
            devices = []
            for addr, name in nearby_devices:
                device_name = name if name else f"Device-{addr[-5:].replace(':', '')}"
                devices.append(BluetoothDeviceInfo(addr, device_name))
                print(f"üì± Found: {device_name} ({addr})")
            
            return devices
            
        except Exception as e:
            print(f"‚ùå PyBluez scan error: {e}")
            return []

    async def _connect_ble_device_async(self, device_info: BluetoothDeviceInfo, device: Device):
        """Async BLE connection using bleak"""
        try:
            print(f"üîó Connecting to BLE device {device_info.name}...")
            
            client = BleakClient(device_info.address)
            await client.connect(timeout=15.0)
            
            if client.is_connected:
                print(f"‚úÖ Connected to {device_info.name}")
                
                device.status = DeviceStatus.CONNECTED
                self.bluetooth_clients[device.device_id] = client
                
                if self.on_device_connected:
                    self.on_device_connected(device.device_id, device.device_name)
                
                # Start data monitoring
                await self._monitor_ble_device(client, device)
            else:
                raise Exception("Failed to establish connection")
                
        except Exception as e:
            print(f"‚ùå BLE connection failed: {e}")
            device.status = DeviceStatus.ERROR
            device.error_message = str(e)

    async def _monitor_ble_device(self, client: BleakClient, device: Device):
        """Monitor BLE device for data"""
        try:
            # Try to find a characteristic for receiving data
            services = await client.get_services()
            
            # Look for common UART service UUIDs
            uart_service_uuids = [
                "6e400001-b5a3-f393-e0a9-e50e24dcca9e",  # Nordic UART
                "0000ffe0-0000-1000-8000-00805f9b34fb",  # Common HC-05 service
            ]
            
            rx_char = None
            for service in services:
                if str(service.uuid).lower() in [uuid.lower() for uuid in uart_service_uuids]:
                    for char in service.characteristics:
                        if "notify" in char.properties or "read" in char.properties:
                            rx_char = char
                            break
                    if rx_char:
                        break
            
            if rx_char:
                print(f"üì° Found data characteristic: {rx_char.uuid}")
                
                def notification_handler(sender: int, data: bytearray):
                    try:
                        message = data.decode('utf-8').strip()
                        self._process_device_data(device.device_id, message)
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Data processing error: {e}")
                
                await client.start_notify(rx_char, notification_handler)
                
                # Keep connection alive
                while client.is_connected and device.device_id in self.devices:
                    await asyncio.sleep(1.0)
                    
            else:
                print("‚ö†Ô∏è  No suitable data characteristic found, using simulated data")
                await self._simulate_ble_data(device)
                
        except Exception as e:
            print(f"‚ùå BLE monitoring error: {e}")
            await self._simulate_ble_data(device)

    async def _simulate_ble_data(self, device: Device):
        """Simulate data for BLE devices without proper characteristics"""
        print(f"üé≠ Simulating data for {device.device_name}")
        
        distance = 50.0
        while device.device_id in self.devices and device.status == DeviceStatus.CONNECTED:
            # Simulate realistic distance changes
            distance += random.uniform(-8, 8)
            distance = max(5, min(200, distance))
            
            self._process_device_data(device.device_id, f"{distance:.1f}")
            await asyncio.sleep(0.5)

    def connect_to_device(self, device_info):
        """Connect to a device (Bluetooth or Serial)"""
        if not device_info:
            print("‚ùå No device info provided")
            return

        try:
            if hasattr(device_info, 'is_bluetooth') and device_info.is_bluetooth:
                self._connect_bluetooth_device(device_info)
            elif isinstance(device_info, ListPortInfo):
                self._connect_serial_device(device_info)
            else:
                print(f"‚ùå Unknown device type: {type(device_info)}")
        except Exception as e:
            print(f"‚ùå Connection error: {e}")

    def _connect_bluetooth_device(self, device_info: BluetoothDeviceInfo):
        """Connect to a Bluetooth device"""
        if not BLUETOOTH_AVAILABLE:
            print("‚ùå Bluetooth not available")
            return

        device_id = f"bt_{device_info.address.replace(':', '_')}"
        
        if device_id in self.devices:
            print(f"‚ö†Ô∏è  Device {device_info.name} already connected")
            return

        print(f"üîó Initiating connection to {device_info.name}...")
        
        device = Device(
            device_id=device_id,
            device_name=device_info.name,
            status=DeviceStatus.CONNECTING,
            connection_time=time.time(),
            connection_info=device_info.address,
            device_type="bluetooth",
            rssi=device_info.rssi
        )
        
        self.devices[device_id] = device
        
        if BLUETOOTH_LIBRARY == "bleak" and self.loop:
            # Use modern bleak connection
            asyncio.run_coroutine_threadsafe(
                self._connect_ble_device_async(device_info, device), self.loop
            )
        else:
            # Fallback to pybluez or simulation
            self._connect_bluetooth_fallback(device_info, device)

    def _connect_bluetooth_fallback(self, device_info: BluetoothDeviceInfo, device: Device):
        """Fallback Bluetooth connection method"""
        def connection_worker():
            try:
                if BLUETOOTH_LIBRARY == "pybluez":
                    self._connect_pybluez_device(device_info, device)
                else:
                    # Simulate connection for demo purposes
                    print(f"üé≠ Simulating connection to {device_info.name}")
                    time.sleep(2)
                    device.status = DeviceStatus.CONNECTED
                    
                    if self.on_device_connected:
                        self.on_device_connected(device.device_id, device.device_name)
                    
                    self._simulate_device_data(device)
                    
            except Exception as e:
                print(f"‚ùå Fallback connection failed: {e}")
                device.status = DeviceStatus.ERROR
                device.error_message = str(e)

        thread = threading.Thread(target=connection_worker, daemon=True)
        thread.start()

    def _connect_pybluez_device(self, device_info: BluetoothDeviceInfo, device: Device):
        """Connect using pybluez (legacy)"""
        try:
            import bluetooth
            
            sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
            sock.settimeout(15)
            
            # Try multiple channels
            connected = False
            for channel in [1, 2, 3, 4]:
                try:
                    print(f"üîó Trying channel {channel}...")
                    sock.connect((device_info.address, channel))
                    connected = True
                    print(f"‚úÖ Connected on channel {channel}")
                    break
                except bluetooth.BluetoothError:
                    continue
            
            if not connected:
                raise bluetooth.BluetoothError("No available channels")
            
            device.status = DeviceStatus.CONNECTED
            if self.on_device_connected:
                self.on_device_connected(device.device_id, device.device_name)
            
            # Start data monitoring
            self._monitor_pybluez_device(sock, device)
            
        except Exception as e:
            print(f"‚ùå PyBluez connection failed: {e}")
            device.status = DeviceStatus.ERROR
            device.error_message = str(e)

    def _monitor_pybluez_device(self, sock, device: Device):
        """Monitor pybluez device for incoming data"""
        try:
            sock.settimeout(1.0)
            buffer = ""
            
            while self.running and device.device_id in self.devices:
                try:
                    data = sock.recv(1024).decode('utf-8', errors='ignore')
                    if data:
                        buffer += data
                        while '\n' in buffer:
                            line, buffer = buffer.split('\n', 1)
                            line = line.strip()
                            if line:
                                self._process_device_data(device.device_id, line)
                except socket.timeout:
                    continue
                except Exception as e:
                    print(f"‚ùå Data read error: {e}")
                    break
                    
        finally:
            try:
                sock.close()
            except:
                pass
            self.disconnect_device(device.device_id)

    def _simulate_device_data(self, device: Device):
        """Simulate device data for testing"""
        distance = 50.0
        while (self.running and 
               device.device_id in self.devices and 
               device.status == DeviceStatus.CONNECTED):
            
            distance += random.uniform(-5, 5)
            distance = max(5, min(200, distance))
            
            self._process_device_data(device.device_id, f"{distance:.1f}")
            time.sleep(0.5)

    def _connect_serial_device(self, port_info: ListPortInfo):
        """Connect to a Serial device"""
        device_id = f"serial_{port_info.device.replace('/', '_').replace('\\', '_')}"
        
        if device_id in self.devices:
            print(f"‚ö†Ô∏è  Serial device already connected: {port_info.device}")
            return

        print(f"üîó Connecting to serial device: {port_info.device}")
        
        device = Device(
            device_id=device_id,
            device_name=port_info.description or f"Serial-{port_info.device}",
            status=DeviceStatus.CONNECTING,
            connection_time=time.time(),
            connection_info=port_info.device,
            device_type="serial"
        )
        
        self.devices[device_id] = device
        self._start_serial_listener(device)

    def _start_serial_listener(self, device: Device):
        """Start serial listener thread"""
        def serial_worker():
            ser = None
            try:
                ser = serial.Serial(device.connection_info, 9600, timeout=1)
                device.status = DeviceStatus.CONNECTED
                
                if self.on_device_connected:
                    self.on_device_connected(device.device_id, device.device_name)
                
                print(f"‚úÖ Serial device connected: {device.device_name}")
                
                while self.running and device.device_id in self.devices:
                    try:
                        line = ser.readline().decode('utf-8', errors='ignore').strip()
                        if line:
                            self._process_device_data(device.device_id, line)
                    except Exception:
                        continue
                        
            except Exception as e:
                print(f"‚ùå Serial connection failed: {e}")
                device.status = DeviceStatus.ERROR
                device.error_message = str(e)
            finally:
                if ser and ser.is_open:
                    ser.close()
                self.disconnect_device(device.device_id)

        thread = threading.Thread(target=serial_worker, daemon=True)
        thread.start()

    def _process_device_data(self, device_id: str, data: str):
        """Process incoming data from any device type"""
        try:
            distance = None
            
            # Try JSON format: {"distance": 15.3}
            if data.startswith('{') and data.endswith('}'):
                try:
                    json_data = json.loads(data)
                    distance = float(json_data.get('distance', 0))
                except:
                    pass
            
            # Try other formats
            if distance is None:
                if data.startswith("DISTANCE:"):
                    distance = float(data.split(":")[1])
                elif 'cm' in data.lower():
                    distance = float(data.lower().replace('cm', '').strip())
                else:
                    distance = float(data.strip())
            
            if distance is not None and distance >= 0:
                self._update_device_distance(device_id, distance)
            
        except (ValueError, IndexError, TypeError) as e:
            print(f"‚ö†Ô∏è  Data parsing error for '{data}': {e}")

    def _update_device_distance(self, device_id: str, distance: float):
        """Update device distance and notify listeners"""
        device = self.devices.get(device_id)
        if device:
            device.last_distance = distance
            device.last_update = time.time()
            
            if self.on_distance_update:
                self.on_distance_update(device_id, distance)

    def disconnect_device(self, device_id: str):
        """Disconnect a device"""
        if device_id in self.devices:
            device = self.devices.pop(device_id)
            device.status = DeviceStatus.DISCONNECTED
            
            # Clean up BLE client if exists
            if device_id in self.bluetooth_clients:
                client = self.bluetooth_clients.pop(device_id)
                if self.loop and BLUETOOTH_LIBRARY == "bleak":
                    asyncio.run_coroutine_threadsafe(
                        self._disconnect_ble_client(client), self.loop
                    )
            
            if self.on_device_disconnected:
                self.on_device_disconnected(device_id)
            
            print(f"üîå Disconnected: {device.device_name}")

    async def _disconnect_ble_client(self, client):
        """Safely disconnect BLE client"""
        try:
            if client.is_connected:
                await client.disconnect()
        except Exception as e:
            print(f"‚ö†Ô∏è  BLE disconnect error: {e}")

    def get_connected_devices(self) -> List[Device]:
        """Get list of connected devices"""
        return [dev for dev in self.devices.values() 
                if dev.status == DeviceStatus.CONNECTED]

    def start_demo_mode(self):
        """Start demo mode with simulated device"""
        if self.demo_mode:
            return
            
        self.demo_mode = True
        self.demo_device = Device(
            device_id="demo_001",
            device_name="Demo HC-05 Bluetooth Device",
            status=DeviceStatus.CONNECTED,
            audio_file="sine_440",
            device_type="demo"
        )
        
        self.devices[self.demo_device.device_id] = self.demo_device
        
        if self.on_device_connected:
            self.on_device_connected(self.demo_device.device_id, self.demo_device.device_name)
        
        # Start demo data generation
        demo_thread = threading.Thread(target=self._demo_worker, daemon=True)
        demo_thread.start()
        
        print("‚úÖ Demo mode activated")

    def _demo_worker(self):
        """Generate demo data"""
        while self.demo_mode and self.running:
            if self.demo_device:
                # Generate realistic distance pattern
                cycle_progress = (time.time() % 30.0) / 30.0
                base_distance = 0.5 * (1 - math.cos(cycle_progress * math.pi * 2))
                distance = max(5.0, min(175.0, base_distance * 170.0 + random.uniform(-3.0, 3.0)))
                
                self._update_device_distance(self.demo_device.device_id, distance)
            
            time.sleep(0.2)  # 5Hz update rate

    def stop_demo_mode(self):
        """Stop demo mode"""
        if not self.demo_mode:
            return
            
        self.demo_mode = False
        if self.demo_device:
            self.disconnect_device(self.demo_device.device_id)
        self.demo_device = None
        
        print("‚úÖ Demo mode deactivated")

    def get_device_statistics(self) -> Dict[str, Any]:
        """Get device manager statistics"""
        connected_count = len(self.get_connected_devices())
        bluetooth_count = len([d for d in self.devices.values() if d.device_type == "bluetooth"])
        serial_count = len([d for d in self.devices.values() if d.device_type == "serial"])
        
        return {
            'total_devices': len(self.devices),
            'connected_devices': connected_count,
            'bluetooth_devices': bluetooth_count,
            'serial_devices': serial_count,
            'demo_devices': 1 if self.demo_mode else 0,
            'demo_mode_active': self.demo_mode,
            'bluetooth_available': BLUETOOTH_AVAILABLE,
            'bluetooth_library': BLUETOOTH_LIBRARY,
            'scanning': self.scanning
        }

    def cleanup(self):
        """Clean up device manager resources"""
        print("üßπ Cleaning up device manager...")
        self.running = False
        
        # Disconnect all devices
        for device_id in list(self.devices.keys()):
            self.disconnect_device(device_id)
        
        # Stop demo mode
        if self.demo_mode:
            self.stop_demo_mode()
        
        # Close async loop
        if self.loop:
            self.loop.call_soon_threadsafe(self.loop.stop)
        
        print("‚úÖ Device manager cleanup complete")"""
pygame_app/src/device_scanner.py
Enhanced Device Scanner Modal Window with Bluetooth Support
Provides a UI for scanning and selecting Bluetooth and serial devices with proper discovery.
"""
import pygame
import pygame.freetype
import serial.tools.list_ports
import threading
import time
from typing import List, Optional, Tuple, Dict, Any
from serial.tools.list_ports_common import ListPortInfo

# Try to import bluetooth functionality
try:
    import bluetooth
    BLUETOOTH_AVAILABLE = True
except ImportError:
    BLUETOOTH_AVAILABLE = False
    print("PyBluez not available. Install with: pip install pybluez")

# Configuration for the popup window
POPUP_WIDTH = 700
POPUP_HEIGHT = 600
COLORS = {
    'background': (25, 30, 40),
    'surface': (35, 42, 55),
    'surface_hover': (45, 52, 65),
    'surface_light': (50, 58, 70),
    'primary': (70, 130, 200),
    'primary_hover': (90, 150, 220),
    'text_primary': (240, 245, 250),
    'text_secondary': (180, 190, 200),
    'text_muted': (140, 150, 160),
    'border': (60, 70, 85),
    'success': (80, 180, 120),
    'warning': (220, 180, 80),
    'error': (220, 80, 80),
}
PADDING = 20

class BluetoothDeviceInfo:
    """Container for Bluetooth device information"""
    def __init__(self, address: str, name: str, device_class: int = 0):
        self.address = address
        self.name = name if name else f"Unknown Device ({address})"
        self.device_class = device_class
        self.device = address  # For compatibility with ListPortInfo interface
        self.description = f"Bluetooth Device - {self.name}"
        self.is_bluetooth = True

class DeviceScanner:
    """A modal window for scanning and selecting Bluetooth and serial devices."""
    
    def __init__(self, parent_screen: pygame.Surface):
        self.parent_screen = parent_screen
        self.parent_size = parent_screen.get_size()
        
        # Don't change display mode - create an overlay instead
        self.screen = parent_screen
        self.modal_surface = pygame.Surface((POPUP_WIDTH, POPUP_HEIGHT))
        self.modal_rect = pygame.Rect(
            (self.parent_size[0] - POPUP_WIDTH) // 2,
            (self.parent_size[1] - POPUP_HEIGHT) // 2,
            POPUP_WIDTH,
            POPUP_HEIGHT
        )
        
        # Initialize fonts
        pygame.freetype.init()
        try:
            self.font_body = pygame.freetype.Font(None, 16)
            self.font_title = pygame.freetype.Font(None, 24)
            self.font_small = pygame.freetype.Font(None, 14)
        except Exception as e:
            print(f"Font initialization error: {e}")
            # Fallback fonts
            self.font_body = pygame.freetype.Font(None, 16)
            self.font_title = pygame.freetype.Font(None, 24)
            self.font_small = pygame.freetype.Font(None, 14)
        
        # Scanner state
        self.available_devices: List[Any] = []  # Mix of ListPortInfo and BluetoothDeviceInfo
        self.selected_device_index: Optional[int] = None
        self.status_message = "Click 'Scan Bluetooth' or 'Scan Serial' to discover devices."
        self.scanning = False
        self.running = True
        self.scan_type = "bluetooth"  # "bluetooth" or "serial"
        
        # UI elements
        self.button_rects = {}
        self.mouse_pos = (0, 0)
        
        # Background overlay
        self.overlay = pygame.Surface(self.parent_size)
        self.overlay.set_alpha(128)
        self.overlay.fill((0, 0, 0))

    def _scan_for_bluetooth_devices(self):
        """Scans for available Bluetooth devices."""
        if self.scanning or not BLUETOOTH_AVAILABLE:
            if not BLUETOOTH_AVAILABLE:
                self.status_message = "Bluetooth not available. Install pybluez: pip install pybluez"
            return
            
        self.scanning = True
        self.scan_type = "bluetooth"
        self.status_message = "Scanning for Bluetooth devices..."
        self.available_devices = []
        self.selected_device_index = None
        
        def bluetooth_scan_worker():
            try:
                self.status_message = "Discovering Bluetooth devices... (this may take 10-15 seconds)"
                
                # Discover Bluetooth devices
                nearby_devices = bluetooth.discover_devices(
                    duration=8,  # Scan for 8 seconds
                    lookup_names=True,
                    flush_cache=True,
                    lookup_class=True
                )
                
                bluetooth_devices = []
                
                # Process discovered devices with better filtering
                for addr, name, device_class in nearby_devices:
                    # Filter for devices of interest
                    device_name = name if name else f"Unknown Device ({addr})"
                    
                    # Check if device name matches patterns of interest
                    interest_patterns = [
                        'SensorNode', 'SENSORNODEB', 'SensorNodeB', 'BluetoothCarIn',
                        'BT_ANURON', 'HC-', 'linvor', 'HC05', 'ESP32', 'Arduino',
                        'NodeMCU', 'Bluetooth', 'BT_', 'Car', 'Audio', 'Speaker'
                    ]
                    
                    is_of_interest = any(pattern.lower() in device_name.lower() for pattern in interest_patterns)
                    
                    # Also include devices with specific class indicators (audio, peripheral, etc.)
                    device_class_major = (device_class >> 8) & 0x1f
                    is_audio_device = device_class_major in [4, 5]  # Audio/Video or Peripheral
                    
                    if is_of_interest or is_audio_device:
                        bluetooth_devices.append(BluetoothDeviceInfo(addr, device_name, device_class))
                        print(f"Found device of interest: {device_name} ({addr}) - Class: {device_class}")
                
                self.available_devices = bluetooth_devices
                
                if not self.available_devices:
                    self.status_message = "No Bluetooth devices of interest found. Try 'Scan All' to see all devices."
                else:
                    self.status_message = f"Found {len(self.available_devices)} Bluetooth device(s) of interest. Select one to connect."
                    
            except Exception as e:
                self.status_message = f"Bluetooth scan error: {str(e)}"
                print(f"Bluetooth scanning error: {e}")
            
            self.scanning = False
        
        # Start scanning in a separate thread
        scan_thread = threading.Thread(target=bluetooth_scan_worker, daemon=True)
        scan_thread.start()

    def _scan_all_bluetooth_devices(self):
        """Scans for ALL Bluetooth devices (not filtered)."""
        if self.scanning or not BLUETOOTH_AVAILABLE:
            return
            
        self.scanning = True
        self.scan_type = "bluetooth"
        self.status_message = "Scanning for ALL Bluetooth devices..."
        self.available_devices = []
        self.selected_device_index = None
        
        def bluetooth_scan_all_worker():
            try:
                self.status_message = "Discovering ALL Bluetooth devices... (this may take 10-15 seconds)"
                
                # Discover ALL Bluetooth devices
                nearby_devices = bluetooth.discover_devices(
                    duration=8,
                    lookup_names=True,
                    flush_cache=True,
                    lookup_class=True
                )
                
                bluetooth_devices = []
                
                for addr, name, device_class in nearby_devices:
                    device_name = name if name else f"Unknown Device ({addr})"
                    bluetooth_devices.append(BluetoothDeviceInfo(addr, device_name, device_class))
                    print(f"Found Bluetooth device: {device_name} ({addr}) - Class: {device_class}")
                
                self.available_devices = bluetooth_devices
                
                if not self.available_devices:
                    self.status_message = "No Bluetooth devices found. Make sure devices are discoverable."
                else:
                    self.status_message = f"Found {len(self.available_devices)} Bluetooth device(s). Select one to connect."
                    
            except Exception as e:
                self.status_message = f"Bluetooth scan error: {str(e)}"
                print(f"Bluetooth scanning error: {e}")
            
            self.scanning = False
        
        # Start scanning in a separate thread
        scan_thread = threading.Thread(target=bluetooth_scan_all_worker, daemon=True)
        scan_thread.start()

    def _scan_for_serial_ports(self):
        """Scans for available serial ports."""
        if self.scanning:
            return
            
        self.scanning = True
        self.scan_type = "serial"
        self.status_message = "Scanning for serial devices..."
        self.available_devices = []
        self.selected_device_index = None
        
        try:
            # Get all available COM ports
            ports = serial.tools.list_ports.comports()
            
            # Filter and organize ports
            self.available_devices = list(ports)
            
            if not self.available_devices:
                self.status_message = "No serial ports found. Make sure your device is connected via USB."
            else:
                self.status_message = f"Found {len(self.available_devices)} serial port(s). Select one to connect."
                
        except Exception as e:
            self.status_message = f"Error during serial scan: {str(e)}"
            print(f"Serial port scanning error: {e}")
        
        self.scanning = False

    def run(self) -> Optional[Any]:
        """Runs the modal window loop and returns the selected device or None."""
        try:
            clock = pygame.time.Clock()
            selected_device = None
            
            while self.running:
                # Handle events
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        self.running = False
                        return None
                    elif event.type == pygame.MOUSEMOTION:
                        # Adjust mouse position to modal coordinates
                        self.mouse_pos = (
                            event.pos[0] - self.modal_rect.x,
                            event.pos[1] - self.modal_rect.y
                        )
                    elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                        # Check if click is within modal
                        if self.modal_rect.collidepoint(event.pos):
                            modal_pos = (
                                event.pos[0] - self.modal_rect.x,
                                event.pos[1] - self.modal_rect.y
                            )
                            self._handle_click(modal_pos)
                        else:
                            # Click outside modal - close it
                            self.running = False
                            return None
                    elif event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_ESCAPE:
                            self.running = False
                            return None
                        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            if self.selected_device_index is not None:
                                selected_device = self.available_devices[self.selected_device_index]
                                self.running = False
                                break

                # Clear the modal surface and render
                self.modal_surface.fill(COLORS['background'])
                self.render()
                
                # Draw overlay on main screen
                self.screen.blit(self.overlay, (0, 0))
                
                # Draw modal on main screen
                self.screen.blit(self.modal_surface, self.modal_rect)
                
                # Draw modal border
                pygame.draw.rect(self.screen, COLORS['border'], self.modal_rect, 3, border_radius=10)
                
                pygame.display.flip()
                clock.tick(60)  # 60 FPS for smooth UI

            # Return selected device
            if self.selected_device_index is not None and self.selected_device_index < len(self.available_devices):
                selected_device = self.available_devices[self.selected_device_index]
                
        except Exception as e:
            print(f"Scanner run error: {e}")
            selected_device = None
        
        return selected_device

    def _handle_click(self, pos: Tuple[int, int]):
        """Handles mouse clicks on buttons and list items."""
        # Bluetooth scan button
        if 'scan_bluetooth' in self.button_rects and self.button_rects['scan_bluetooth'].collidepoint(pos):
            if not self.scanning:
                self._scan_for_bluetooth_devices()
            return

        # Scan all Bluetooth button
        if 'scan_all_bluetooth' in self.button_rects and self.button_rects['scan_all_bluetooth'].collidepoint(pos):
            if not self.scanning:
                self._scan_all_bluetooth_devices()
            return

        # Serial scan button
        if 'scan_serial' in self.button_rects and self.button_rects['scan_serial'].collidepoint(pos):
            if not self.scanning:
                self._scan_for_serial_ports()
            return

        # Connect button
        if 'connect' in self.button_rects and self.button_rects['connect'].collidepoint(pos):
            if self.selected_device_index is not None:
                self.running = False
            return

        # Cancel button
        if 'cancel' in self.button_rects and self.button_rects['cancel'].collidepoint(pos):
            self.selected_device_index = None
            self.running = False
            return

        # Device list items
        list_start_y = 140
        item_height = 60
        
        for i, device in enumerate(self.available_devices):
            item_y = list_start_y + i * (item_height + 5)
            item_rect = pygame.Rect(PADDING, item_y, POPUP_WIDTH - PADDING * 2, item_height)
            
            if item_rect.collidepoint(pos):
                self.selected_device_index = i
                break

    def render(self):
        """Renders the entire scanner window."""
        # Clear button rects
        self.button_rects.clear()
        
        # Render all components to the modal surface
        self._render_header()
        self._render_status()
        self._render_device_list()
        self._render_buttons()
        self._render_instructions()

    def _render_header(self):
        """Render the header section."""
        header_rect = pygame.Rect(0, 0, POPUP_WIDTH, 60)
        pygame.draw.rect(self.modal_surface, COLORS['surface'], header_rect)
        pygame.draw.line(self.modal_surface, COLORS['border'], 
                        header_rect.bottomleft, header_rect.bottomright, 2)
        
        # Title
        self.font_title.render_to(self.modal_surface, (PADDING, 15), 
                                "Enhanced Device Scanner", COLORS['text_primary'])
        
        # Subtitle
        subtitle = "Bluetooth & Serial Device Discovery"
        if not BLUETOOTH_AVAILABLE:
            subtitle += " (Bluetooth disabled - install pybluez)"
        self.font_small.render_to(self.modal_surface, (PADDING, 35), subtitle, COLORS['text_secondary'])

    def _render_status(self):
        """Render the status message."""
        status_y = 70
        
        # Status background
        status_rect = pygame.Rect(PADDING, status_y, POPUP_WIDTH - PADDING * 2, 35)
        pygame.draw.rect(self.modal_surface, COLORS['surface_light'], status_rect, border_radius=5)
        
        # Status text with appropriate color
        if "Error" in self.status_message or "error" in self.status_message:
            status_color = COLORS['error']
        elif "Scanning" in self.status_message or "Discovering" in self.status_message:
            status_color = COLORS['warning']
        elif "Found" in self.status_message:
            status_color = COLORS['success']
        else:
            status_color = COLORS['text_secondary']
        
        # Wrap long messages
        message = self.status_message
        if len(message) > 70:
            message = message[:67] + "..."
        
        self.font_body.render_to(self.modal_surface, (status_rect.x + 10, status_rect.y + 10), 
                               message, status_color)

    def _render_device_list(self):
        """Render the list of available devices."""
        list_start_y = 140
        list_height = POPUP_HEIGHT - list_start_y - 100  # Leave space for buttons
        item_height = 60
        
        # List background
        list_rect = pygame.Rect(PADDING, list_start_y, POPUP_WIDTH - PADDING * 2, list_height)
        pygame.draw.rect(self.modal_surface, COLORS['surface'], list_rect, border_radius=8)
        pygame.draw.rect(self.modal_surface, COLORS['border'], list_rect, 2, border_radius=8)
        
        if not self.available_devices:
            # No devices message
            if self.scanning:
                msg = "Scanning for devices..."
            else:
                msg = "No devices found. Use scan buttons to search for devices."
            
            text_rect = self.font_body.get_rect(msg)
            text_x = list_rect.centerx - text_rect.width // 2
            text_y = list_rect.centery - text_rect.height // 2
            
            self.font_body.render_to(self.modal_surface, (text_x, text_y), msg, COLORS['text_muted'])
            return

        # Render device items
        visible_items = min(len(self.available_devices), (list_height - 10) // (item_height + 5))
        
        for i in range(visible_items):
            device = self.available_devices[i]
            item_y = list_start_y + 5 + i * (item_height + 5)
            item_rect = pygame.Rect(PADDING + 5, item_y, POPUP_WIDTH - PADDING * 2 - 10, item_height)
            
            # Item background
            if i == self.selected_device_index:
                item_color = COLORS['primary']
                text_color = COLORS['text_primary']
                desc_color = COLORS['text_primary']
            elif item_rect.collidepoint(self.mouse_pos):
                item_color = COLORS['surface_hover']
                text_color = COLORS['text_primary']
                desc_color = COLORS['text_secondary']
            else:
                item_color = COLORS['surface_light']
                text_color = COLORS['text_secondary']
                desc_color = COLORS['text_muted']
            
            pygame.draw.rect(self.modal_surface, item_color, item_rect, border_radius=5)
            
            # Device information
            if hasattr(device, 'is_bluetooth'):
                # Bluetooth device
                device_name = device.name
                device_info = f"Bluetooth: {device.address}"
                type_indicator = "üîµ BT"
            else:
                # Serial device
                device_name = getattr(device, 'device', 'Unknown Port')
                device_info = getattr(device, 'description', 'No description')
                type_indicator = "üîå USB"
            
            # Truncate long names
            if len(device_name) > 35:
                device_name = device_name[:32] + "..."
            if len(device_info) > 45:
                device_info = device_info[:42] + "..."
            
            # Render device info
            self.font_body.render_to(self.modal_surface, (item_rect.x + 10, item_rect.y + 8), 
                                   device_name, text_color)
            self.font_small.render_to(self.modal_surface, (item_rect.x + 10, item_rect.y + 28), 
                                    device_info, desc_color)
            
            # Type indicator
            self.font_small.render_to(self.modal_surface, (item_rect.right - 60, item_rect.y + 8), 
                                    type_indicator, text_color)

    def _render_buttons(self):
        """Render control buttons."""
        button_y = POPUP_HEIGHT - 70
        button_height = 35
        button_width = 100
        spacing = 10
        
        # Button configurations
        buttons = []
        
        # Bluetooth buttons (if available)
        if BLUETOOTH_AVAILABLE:
            buttons.extend([
                ('scan_bluetooth', 'Scan BT', COLORS['primary'], 20),
                ('scan_all_bluetooth', 'Scan All BT', COLORS['warning'], 130),
            ])
        
        # Serial button
        buttons.append(('scan_serial', 'Scan Serial', COLORS['success'], 250 if BLUETOOTH_AVAILABLE else 20))
        
        # Control buttons
        buttons.extend([
            ('connect', 'Connect', COLORS['success'], POPUP_WIDTH - 220),
            ('cancel', 'Cancel', COLORS['error'], POPUP_WIDTH - 110)
        ])
        
        for btn_id, btn_text, btn_color, btn_x in buttons:
            if btn_id == 'connect' and self.selected_device_index is None:
                btn_color = COLORS['surface_light']  # Disabled state
            
            button_rect = pygame.Rect(btn_x, button_y, button_width, button_height)
            
            # Button hover effect
            if button_rect.collidepoint(self.mouse_pos) and not self.scanning:
                if btn_id != 'connect' or self.selected_device_index is not None:
                    hover_color = tuple(min(255, c + 20) for c in btn_color)
                    pygame.draw.rect(self.modal_surface, hover_color, button_rect, border_radius=6)
                else:
                    pygame.draw.rect(self.modal_surface, btn_color, button_rect, border_radius=6)
            else:
                pygame.draw.rect(self.modal_surface, btn_color, button_rect, border_radius=6)
            
            # Button border
            pygame.draw.rect(self.modal_surface, COLORS['border'], button_rect, 1, border_radius=6)
            
            # Button text
            text_color = COLORS['text_primary']
            if btn_id == 'connect' and self.selected_device_index is None:
                text_color = COLORS['text_muted']
            
            text_surf, text_rect = self.font_body.render(btn_text, text_color)
            text_rect.center = button_rect.center
            self.modal_surface.blit(text_surf, text_rect)
            
            self.button_rects[btn_id] = button_rect

    def _render_instructions(self):
        """Render usage instructions."""
        instruction_y = POPUP_HEIGHT - 25
        
        if BLUETOOTH_AVAILABLE:
            instructions = "Bluetooth: Scan BT for HC-05 devices ‚Ä¢ Serial: USB connections ‚Ä¢ Enter to connect ‚Ä¢ Esc to cancel"
        else:
            instructions = "Install pybluez for Bluetooth support ‚Ä¢ Serial: USB connections ‚Ä¢ Enter to connect ‚Ä¢ Esc to cancel"
        
        self.font_small.render_to(self.modal_surface, (PADDING, instruction_y), 
                                instructions, COLORS['text_muted'])

    def cleanup(self):
        """Clean up scanner resources."""
        # No display mode changes to undo - just ensure the scanner is closed
        self.running = False"""
pygame_app/src/ui_manager.py
Enhanced UI Manager with Navigation and Improved Layout
"""
import pygame
import pygame.freetype
import time
from typing import Dict, List, Optional, Callable, Tuple, Any
from enum import Enum

from .config import Config
from .audio_engine import SpatialAudioEngine, AudioSource
from .device_manager import DeviceManager, Device, DeviceStatus
from .device_scanner import DeviceScanner

class NavigationPage(Enum):
    HOME = "Home"
    SIMULATION = "Simulation"
    MISC = "Settings"

class UIManager:
    def __init__(self, screen: pygame.Surface, audio_engine: SpatialAudioEngine, device_manager: DeviceManager):
        print("Initializing Enhanced UI Manager...")
        self.screen = screen
        self.original_screen_size = (screen.get_width(), screen.get_height())
        self.audio_engine = audio_engine
        self.device_manager = device_manager
        
        # Navigation state
        self.current_page = NavigationPage.HOME
        
        pygame.freetype.init()
        self.fonts = self._load_fonts()
        
        # UI State
        self.expanded_sections = {
            'device_management': True, 'device_list': True, 'audio_effects': True,
            'device_status': True, 'distance_monitoring': True, 'volume_monitoring': True, 
            'log_panel': True, 'audio_assignment': True
        }
        
        # Audio settings
        self.audio_effects = {'master_volume': 75.0}
        self.distance_settings = {
            'min_distance': 5.0, 'max_distance': 200.0, 'min_volume': 5.0, 
            'max_volume': 100.0, 'decay_type': 'exponential'
        }
        
        # Device management
        self.device_enabled_states: Dict[str, bool] = {}
        self.device_audio_assignments: Dict[str, str] = {}
        
        # Data tracking
        self.log_entries: List[Tuple[float, str, str]] = []
        self.max_log_entries = 100
        self.distance_data: Dict[str, List[Tuple[float, float]]] = {}
        self.volume_data: Dict[str, List[Tuple[float, float]]] = {}
        
        # Interaction handling
        self.button_rects: Dict[str, pygame.Rect] = {}
        self.slider_rects: Dict[str, pygame.Rect] = {}
        self.checkbox_rects: Dict[str, pygame.Rect] = {}
        self.dropdown_rects: Dict[str, pygame.Rect] = {}
        self.mouse_pos = (0, 0)
        self.last_click_time = 0
        self.dragging_slider = None
        
        # Setup device manager callbacks
        self.device_manager.on_device_connected = self._on_device_connected
        self.device_manager.on_device_disconnected = self._on_device_disconnected
        self.device_manager.on_distance_update = self._on_distance_update
        
        self.add_log_entry("Enhanced UI Manager Initialized", "success")

    def _load_fonts(self) -> Dict[str, pygame.freetype.Font]:
        fonts = {}
        try:
            for name, (_, size) in Config.FONTS.items():
                fonts[name] = pygame.freetype.Font(None, size)
        except Exception as e:
            print(f"Font loading error: {e}")
            # Fallback to default font
            for name in Config.FONTS.keys():
                fonts[name] = pygame.freetype.Font(None, 14)
        return fonts

    def _on_device_connected(self, device_id: str, device_name: str):
        self.device_enabled_states[device_id] = True
        self.device_audio_assignments[device_id] = "sine_440"  # Default audio source
        self.add_log_entry(f"Device connected: {device_name}", "success")

    def _on_device_disconnected(self, device_id: str):
        self.device_enabled_states.pop(device_id, None)
        self.device_audio_assignments.pop(device_id, None)
        self.distance_data.pop(device_id, None)
        self.volume_data.pop(device_id, None)
        self.add_log_entry(f"Device disconnected: {device_id}", "info")

    def _on_distance_update(self, device_id: str, distance: float):
        self.update_device_distance(device_id, distance)
        
        # Synthesize audio if device is enabled
        if self.device_enabled_states.get(device_id, False):
            volume = self._calculate_volume_from_distance(distance)
            frequency = self._calculate_frequency_from_distance(distance)
            audio_source = self.device_audio_assignments.get(device_id, "sine_440")
            
            self.audio_engine.synthesize_audio(
                device_id=device_id,
                frequency=frequency,
                volume=volume / 100.0,  # Convert percentage to 0-1
                audio_file=audio_source,
                duration=0.1
            )

    def add_log_entry(self, message: str, level: str = "info"):
        self.log_entries.append((time.time(), message, level))
        if len(self.log_entries) > self.max_log_entries:
            self.log_entries.pop(0)

    def handle_event(self, event: pygame.event.Event):
        if event.type == pygame.MOUSEMOTION:
            self.mouse_pos = event.pos
            self._handle_slider_drag(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if time.time() - self.last_click_time > 0.2:
                self._handle_click(event.pos)
                self.last_click_time = time.time()
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.dragging_slider = None

    def _handle_click(self, pos: Tuple[int, int]):
        # Check navigation buttons
        for page in NavigationPage:
            nav_key = f"nav_{page.value.lower()}"
            if nav_key in self.button_rects and self.button_rects[nav_key].collidepoint(pos):
                self.current_page = page
                self.add_log_entry(f"Navigated to {page.value} page")
                return

        # Handle page-specific clicks
        if self.current_page == NavigationPage.HOME:
            self._handle_home_click(pos)

    def _handle_home_click(self, pos: Tuple[int, int]):
        # Device management buttons
        if 'scan_devices' in self.button_rects and self.button_rects['scan_devices'].collidepoint(pos):
            self._scan_for_devices()
            return

        if 'demo_toggle' in self.button_rects and self.button_rects['demo_toggle'].collidepoint(pos):
            if self.device_manager.demo_mode:
                self.device_manager.stop_demo_mode()
                self.add_log_entry("Demo mode disabled")
            else:
                self.device_manager.start_demo_mode()
                self.add_log_entry("Demo mode enabled", "success")
            return

        # Test audio button
        if 'test_audio' in self.button_rects and self.button_rects['test_audio'].collidepoint(pos):
            self.audio_engine.generate_test_tone(440.0, 0.5, 1.0)
            self.add_log_entry("Test tone generated", "info")
            return

        # Device enable/disable checkboxes
        for device_id in list(self.device_enabled_states.keys()):
            checkbox_key = f"enable_{device_id}"
            if checkbox_key in self.checkbox_rects and self.checkbox_rects[checkbox_key].collidepoint(pos):
                self.device_enabled_states[device_id] = not self.device_enabled_states[device_id]
                status = "enabled" if self.device_enabled_states[device_id] else "disabled"
                self.add_log_entry(f"Device {device_id} {status}")
                return

        # Audio assignment dropdowns (simplified click handling)
        for device_id in list(self.device_audio_assignments.keys()):
            dropdown_key = f"audio_{device_id}"
            if dropdown_key in self.dropdown_rects and self.dropdown_rects[dropdown_key].collidepoint(pos):
                self._cycle_audio_assignment(device_id)
                return

        # Slider handling
        for slider_name, slider_rect in self.slider_rects.items():
            if slider_rect.collidepoint(pos):
                self.dragging_slider = slider_name
                self._update_slider_value(slider_name, pos, slider_rect)
                return

    def _scan_for_devices(self):
        self.add_log_entry("Opening device scanner...")
        try:
            # Store current screen mode
            current_mode = pygame.display.get_surface()
            
            scanner = DeviceScanner(self.screen)
            selected_port = scanner.run()
            
            # Restore original screen mode properly
            pygame.display.set_mode(self.original_screen_size)
            
            if selected_port:
                self.add_log_entry(f"Device selected: {selected_port.device}", "info")
                self.device_manager.connect_to_device(selected_port)
            else:
                self.add_log_entry("Device selection cancelled.", "info")
                
        except Exception as e:
            self.add_log_entry(f"Scanner error: {e}", "error")
            # Ensure screen is restored even on error
            pygame.display.set_mode(self.original_screen_size)

    def _cycle_audio_assignment(self, device_id: str):
        audio_sources = self.audio_engine.get_audio_sources()
        if not audio_sources:
            return
            
        current_source = self.device_audio_assignments.get(device_id, audio_sources[0].id)
        current_index = 0
        
        for i, source in enumerate(audio_sources):
            if source.id == current_source:
                current_index = i
                break
                
        next_index = (current_index + 1) % len(audio_sources)
        new_source = audio_sources[next_index]
        
        self.device_audio_assignments[device_id] = new_source.id
        self.add_log_entry(f"Assigned {new_source.name} to {device_id}")

    def _handle_slider_drag(self, pos: Tuple[int, int]):
        if self.dragging_slider and self.dragging_slider in self.slider_rects:
            slider_rect = self.slider_rects[self.dragging_slider]
            self._update_slider_value(self.dragging_slider, pos, slider_rect)

    def _update_slider_value(self, slider_name: str, pos: Tuple[int, int], slider_rect: pygame.Rect):
        # Calculate value based on position
        relative_x = max(0, min(slider_rect.width, pos[0] - slider_rect.x))
        value_ratio = relative_x / slider_rect.width
        
        if slider_name == 'master_volume':
            self.audio_effects['master_volume'] = value_ratio * 100
            self.audio_engine.set_master_volume(value_ratio)
        elif slider_name.startswith('min_distance'):
            self.distance_settings['min_distance'] = value_ratio * 50
        elif slider_name.startswith('max_distance'):
            self.distance_settings['max_distance'] = 50 + (value_ratio * 200)

    def update_device_distance(self, device_id: str, distance: float):
        current_time = time.time()
        if device_id not in self.distance_data:
            self.distance_data[device_id] = []
        if device_id not in self.volume_data:
            self.volume_data[device_id] = []
        
        volume = self._calculate_volume_from_distance(distance)
        self.distance_data[device_id].append((current_time, distance))
        self.volume_data[device_id].append((current_time, volume))

        # Keep only last 60 seconds of data
        cutoff = current_time - 60.0
        self.distance_data[device_id] = [d for d in self.distance_data[device_id] if d[0] > cutoff]
        self.volume_data[device_id] = [v for v in self.volume_data[device_id] if v[0] > cutoff]

    def _calculate_volume_from_distance(self, distance: float) -> float:
        s = self.distance_settings
        if distance <= s['min_distance']:
            return s['max_volume']
        if distance >= s['max_distance']:
            return s['min_volume']
        
        normalized = (distance - s['min_distance']) / (s['max_distance'] - s['min_distance'])
        
        if s['decay_type'] == 'exponential':
            factor = pow(0.1, normalized)
        else:  # linear
            factor = 1.0 - normalized
            
        return s['min_volume'] + (s['max_volume'] - s['min_volume']) * factor

    def _calculate_frequency_from_distance(self, distance: float) -> float:
        # Map distance to frequency range (200-1000 Hz)
        min_freq, max_freq = 200, 1000
        s = self.distance_settings
        
        if distance <= s['min_distance']:
            return max_freq
        if distance >= s['max_distance']:
            return min_freq
            
        normalized = (distance - s['min_distance']) / (s['max_distance'] - s['min_distance'])
        return max_freq - (normalized * (max_freq - min_freq))

    def render(self):
        # Clear button rects for this frame
        self.button_rects.clear()
        self.checkbox_rects.clear()
        self.dropdown_rects.clear()
        self.slider_rects.clear()
        
        # Fill background
        self.screen.fill(Config.COLORS['background'])
        
        # Render navigation and content
        self._render_navigation()
        
        if self.current_page == NavigationPage.HOME:
            self._render_home_page()
        elif self.current_page == NavigationPage.SIMULATION:
            self._render_simulation_page()
        elif self.current_page == NavigationPage.MISC:
            self._render_misc_page()

    def _render_navigation(self):
        nav_height = 50
        nav_rect = pygame.Rect(0, 0, self.screen.get_width(), nav_height)
        
        # Navigation background
        pygame.draw.rect(self.screen, Config.COLORS['surface'], nav_rect)
        pygame.draw.line(self.screen, Config.COLORS['border'], 
                        nav_rect.bottomleft, nav_rect.bottomright, 2)
        
        # Navigation buttons
        button_width = 120
        button_height = 30
        start_x = Config.LAYOUT['padding']
        y = (nav_height - button_height) // 2
        
        for i, page in enumerate(NavigationPage):
            x = start_x + i * (button_width + 10)
            button_rect = pygame.Rect(x, y, button_width, button_height)
            
            # Button styling
            if page == self.current_page:
                color = Config.COLORS['primary']
                text_color = Config.COLORS['text_primary']
            else:
                color = Config.COLORS['surface_light']
                text_color = Config.COLORS['text_secondary']
                
            pygame.draw.rect(self.screen, color, button_rect, border_radius=5)
            
            # Button text
            text_surf, text_rect = self.fonts['body'].render(page.value, text_color)
            text_rect.center = button_rect.center
            self.screen.blit(text_surf, text_rect)
            
            self.button_rects[f"nav_{page.value.lower()}"] = button_rect

    def _render_home_page(self):
        content_y = 60  # Start below navigation
        content_height = self.screen.get_height() - content_y
        
        # Two-column layout
        left_width = 400
        right_width = self.screen.get_width() - left_width - Config.LAYOUT['padding'] * 3
        
        left_rect = pygame.Rect(Config.LAYOUT['padding'], content_y, 
                               left_width, content_height - Config.LAYOUT['padding'])
        right_rect = pygame.Rect(left_rect.right + Config.LAYOUT['padding'], content_y,
                                right_width, content_height - Config.LAYOUT['padding'])
        
        # Render left column
        y_offset = 0
        y_offset += self._render_section(left_rect, y_offset, "Device Management", 
                                       self._render_device_management_content, 120)
        y_offset += self._render_section(left_rect, y_offset, "Connected Devices", 
                                       self._render_device_list_content, 200)
        y_offset += self._render_section(left_rect, y_offset, "Audio Settings", 
                                       self._render_audio_settings_content, 180)
        
        # Render right column
        y_offset_right = 0
        y_offset_right += self._render_section(right_rect, y_offset_right, "Device Status Overview", 
                                             self._render_device_status_content, 150)
        y_offset_right += self._render_section(right_rect, y_offset_right, "Real-Time Distance (cm)", 
                                             lambda r: self._render_chart(r, self.distance_data, 0, 200), 200)
        y_offset_right += self._render_section(right_rect, y_offset_right, "Real-Time Volume (%)", 
                                             lambda r: self._render_chart(r, self.volume_data, 0, 100), 200)
        y_offset_right += self._render_section(right_rect, y_offset_right, "System Logs", 
                                             self._render_log_panel_content, 150)

    def _render_simulation_page(self):
        content_rect = pygame.Rect(Config.LAYOUT['padding'], 70, 
                                  self.screen.get_width() - Config.LAYOUT['padding'] * 2,
                                  self.screen.get_height() - 90)
        
        pygame.draw.rect(self.screen, Config.COLORS['surface'], content_rect, border_radius=10)
        
        # Centered message
        message = "Simulation Page - Coming Soon"
        text_surf, text_rect = self.fonts['title'].render(message, Config.COLORS['text_primary'])
        text_rect.center = content_rect.center
        self.screen.blit(text_surf, text_rect)

    def _render_misc_page(self):
        content_rect = pygame.Rect(Config.LAYOUT['padding'], 70, 
                                  self.screen.get_width() - Config.LAYOUT['padding'] * 2,
                                  self.screen.get_height() - 90)
        
        pygame.draw.rect(self.screen, Config.COLORS['surface'], content_rect, border_radius=10)
        
        # Centered message
        message = "Miscellaneous Page - Coming Soon"
        text_surf, text_rect = self.fonts['title'].render(message, Config.COLORS['text_primary'])
        text_rect.center = content_rect.center
        self.screen.blit(text_surf, text_rect)

    def _render_section(self, parent_rect: pygame.Rect, y_offset: int, title: str, 
                       content_renderer: Callable, height: int) -> int:
        section_rect = pygame.Rect(parent_rect.x, parent_rect.y + y_offset, 
                                  parent_rect.width, height)
        
        # Section background
        pygame.draw.rect(self.screen, Config.COLORS['surface'], section_rect, border_radius=8)
        pygame.draw.rect(self.screen, Config.COLORS['border'], section_rect, 2, border_radius=8)
        
        # Section header
        header_rect = pygame.Rect(section_rect.x, section_rect.y, section_rect.width, 35)
        pygame.draw.rect(self.screen, Config.COLORS['surface_light'], header_rect, 
                        border_top_left_radius=8, border_top_right_radius=8)
        
        self.fonts['heading'].render_to(self.screen, (header_rect.x + 15, header_rect.y + 8), 
                                       title, Config.COLORS['text_primary'])
        
        # Section content
        content_rect = pygame.Rect(section_rect.x + 15, header_rect.bottom + 10,
                                  section_rect.width - 30, section_rect.height - 50)
        content_renderer(content_rect)
        
        return height + Config.LAYOUT['padding']

    def _render_device_management_content(self, rect: pygame.Rect):
        button_height = 35
        button_width = 160
        spacing = 10
        
        # Scan button
        scan_rect = pygame.Rect(rect.x, rect.y, button_width, button_height)
        self._render_button(scan_rect, 'scan_devices', "Scan for Devices", Config.COLORS['primary'])
        
        # Demo toggle
        demo_text = "Disable Demo" if self.device_manager.demo_mode else "Enable Demo"
        demo_color = Config.COLORS['error'] if self.device_manager.demo_mode else Config.COLORS['success']
        demo_rect = pygame.Rect(scan_rect.right + spacing, rect.y, button_width, button_height)
        self._render_button(demo_rect, 'demo_toggle', demo_text, demo_color)
        
        # Test audio button
        test_rect = pygame.Rect(rect.x, scan_rect.bottom + spacing, button_width, button_height)
        self._render_button(test_rect, 'test_audio', "Test Audio", Config.COLORS['info'])

    def _render_device_list_content(self, rect: pygame.Rect):
        devices = list(self.device_manager.devices.values())
        if not devices:
            self.fonts['body'].render_to(self.screen, rect.topleft, 
                                       "No devices connected.", Config.COLORS['text_muted'])
            return
        
        y_pos = rect.y
        for device in devices:
            if y_pos + 60 > rect.bottom:
                break
                
            device_id = device.device_id
            
            # Device info
            status_colors = {
                'connected': Config.COLORS['success'],
                'connecting': Config.COLORS['warning'],
                'error': Config.COLORS['error']
            }
            status_color = status_colors.get(device.status.value, Config.COLORS['text_muted'])
            
            # Device name and status
            name_text = f"{device.device_name[:25]}"
            self.fonts['body'].render_to(self.screen, (rect.x, y_pos), name_text, Config.COLORS['text_primary'])
            
            status_text = f"[{device.status.value.upper()}]"
            self.fonts['small'].render_to(self.screen, (rect.x, y_pos + 20), status_text, status_color)
            
            if device.status == DeviceStatus.CONNECTED:
                # Enable/disable checkbox
                checkbox_rect = pygame.Rect(rect.x, y_pos + 35, 15, 15)
                checkbox_key = f"enable_{device_id}"
                
                enabled = self.device_enabled_states.get(device_id, True)
                checkbox_color = Config.COLORS['primary'] if enabled else Config.COLORS['surface_light']
                pygame.draw.rect(self.screen, checkbox_color, checkbox_rect, border_radius=3)
                
                if enabled:
                    # Checkmark
                    pygame.draw.lines(self.screen, Config.COLORS['text_primary'], False,
                                    [(checkbox_rect.x + 3, checkbox_rect.y + 7),
                                     (checkbox_rect.x + 6, checkbox_rect.y + 10),
                                     (checkbox_rect.x + 12, checkbox_rect.y + 4)], 2)
                
                self.checkbox_rects[checkbox_key] = checkbox_rect
                
                # Audio assignment dropdown (simplified)
                audio_rect = pygame.Rect(checkbox_rect.right + 10, y_pos + 35, 150, 20)
                current_audio = self.device_audio_assignments.get(device_id, "sine_440")
                
                # Find audio source name
                audio_name = "Unknown"
                for source in self.audio_engine.get_audio_sources():
                    if source.id == current_audio:
                        audio_name = source.name[:20]
                        break
                
                pygame.draw.rect(self.screen, Config.COLORS['surface_light'], audio_rect, border_radius=3)
                self.fonts['small'].render_to(self.screen, (audio_rect.x + 5, audio_rect.y + 3),
                                            f"Audio: {audio_name}", Config.COLORS['text_secondary'])
                
                self.dropdown_rects[f"audio_{device_id}"] = audio_rect
            
            y_pos += 60

    def _render_audio_settings_content(self, rect: pygame.Rect):
        y_pos = rect.y
        
        # Master volume slider
        self.fonts['body'].render_to(self.screen, (rect.x, y_pos), 
                                   f"Master Volume: {self.audio_effects['master_volume']:.0f}%", 
                                   Config.COLORS['text_primary'])
        
        slider_rect = pygame.Rect(rect.x, y_pos + 25, 200, 20)
        self._render_slider(slider_rect, 'master_volume', self.audio_effects['master_volume'] / 100.0)
        
        y_pos += 60
        
        # Distance settings
        self.fonts['body'].render_to(self.screen, (rect.x, y_pos), 
                                   "Distance Mapping:", Config.COLORS['text_primary'])
        y_pos += 25
        
        self.fonts['small'].render_to(self.screen, (rect.x, y_pos), 
                                    f"Min Distance: {self.distance_settings['min_distance']:.1f} cm", 
                                    Config.COLORS['text_secondary'])
        
        self.fonts['small'].render_to(self.screen, (rect.x, y_pos + 15), 
                                    f"Max Distance: {self.distance_settings['max_distance']:.1f} cm", 
                                    Config.COLORS['text_secondary'])

    def _render_device_status_content(self, rect: pygame.Rect):
        devices = self.device_manager.get_connected_devices()
        if not devices:
            self.fonts['body'].render_to(self.screen, rect.topleft, 
                                       "No active devices to monitor.", Config.COLORS['text_muted'])
            return

        y_pos = rect.y
        for device in devices:
            if y_pos + 50 > rect.bottom:
                break
                
            enabled = self.device_enabled_states.get(device.device_id, True)
            if not enabled:
                continue
                
            # Device name
            name_text = f"{device.device_name[:25]}"
            self.fonts['body'].render_to(self.screen, (rect.x, y_pos), name_text, Config.COLORS['text_primary'])
            
            # Distance and volume
            dist_text = f"Distance: {device.last_distance:.1f} cm"
            vol = self._calculate_volume_from_distance(device.last_distance)
            vol_text = f"Volume: {vol:.1f}%"
            
            self.fonts['small'].render_to(self.screen, (rect.x, y_pos + 20), 
                                        f"{dist_text}  |  {vol_text}", Config.COLORS['text_secondary'])
            
            y_pos += 45

    def _render_chart(self, rect: pygame.Rect, data_source: Dict[str, List], min_val: float, max_val: float):
        # Chart background
        pygame.draw.rect(self.screen, Config.COLORS['background'], rect)
        pygame.draw.rect(self.screen, Config.COLORS['border'], rect, 1)
        
        if not data_source:
            self.fonts['body'].render_to(self.screen, (rect.centerx - 50, rect.centery), 
                                       "No Data", Config.COLORS['text_muted'])
            return
        
        current_time = time.time()
        
        for i, (device_id, data_points) in enumerate(data_source.items()):
            if len(data_points) < 2:
                continue
                
            # Only show enabled devices
            if not self.device_enabled_states.get(device_id, True):
                continue
                
            color = Config.get_chart_color(i)
            points = []
            
            for timestamp, value in data_points:
                # Calculate position
                time_ratio = max(0, min(1, (current_time - timestamp) / 60.0))  # Last 60 seconds
                value_ratio = (value - min_val) / (max_val - min_val) if max_val > min_val else 0
                value_ratio = max(0, min(1, value_ratio))
                
                x = rect.right - (time_ratio * rect.width)
                y = rect.bottom - (value_ratio * rect.height)
                points.append((x, y))
            
            if len(points) > 1:
                try:
                    pygame.draw.lines(self.screen, color, False, points, 2)
                except ValueError:
                    pass  # Skip invalid points

    def _render_log_panel_content(self, rect: pygame.Rect):
        if not self.log_entries:
            self.fonts['body'].render_to(self.screen, rect.topleft, 
                                       "No log entries.", Config.COLORS['text_muted'])
            return
        
        y_pos = rect.y
        visible_entries = list(reversed(self.log_entries))[-8:]  # Show last 8 entries
        
        for timestamp, message, level in visible_entries:
            if y_pos + 18 > rect.bottom:
                break
                
            # Color based on log level
            level_colors = {
                'info': Config.COLORS['text_secondary'],
                'success': Config.COLORS['success'],
                'error': Config.COLORS['error'],
                'warning': Config.COLORS['warning']
            }
            color = level_colors.get(level, Config.COLORS['text_primary'])
            
            # Format timestamp
            time_str = time.strftime('%H:%M:%S', time.localtime(timestamp))
            log_text = f"[{time_str}] {message[:50]}"
            
            self.fonts['small'].render_to(self.screen, (rect.x, y_pos), log_text, color)
            y_pos += 18

    def _render_button(self, rect: pygame.Rect, name: str, text: str, color: Tuple[int, int, int]):
        # Button hover effect
        if rect.collidepoint(self.mouse_pos):
            hover_color = tuple(min(255, c + 20) for c in color)
            pygame.draw.rect(self.screen, hover_color, rect, border_radius=6)
        else:
            pygame.draw.rect(self.screen, color, rect, border_radius=6)
        
        # Button border
        pygame.draw.rect(self.screen, Config.COLORS['border'], rect, 2, border_radius=6)
        
        # Button text
        text_surf, text_rect = self.fonts['body'].render(text, Config.COLORS['text_primary'])
        text_rect.center = rect.center
        self.screen.blit(text_surf, text_rect)
        
        self.button_rects[name] = rect

    def _render_slider(self, rect: pygame.Rect, name: str, value: float):
        # Slider track
        pygame.draw.rect(self.screen, Config.COLORS['surface_light'], rect, border_radius=10)
        pygame.draw.rect(self.screen, Config.COLORS['border'], rect, 1, border_radius=10)
        
        # Slider handle
        handle_x = rect.x + (value * (rect.width - 10))
        handle_rect = pygame.Rect(handle_x, rect.y - 2, 10, rect.height + 4)
        pygame.draw.rect(self.screen, Config.COLORS['primary'], handle_rect, border_radius=5)
        
        # Filled portion
        filled_rect = pygame.Rect(rect.x, rect.y, handle_x - rect.x + 5, rect.height)
        pygame.draw.rect(self.screen, Config.COLORS['primary'], filled_rect, border_radius=10)
        
        self.slider_rects[name] = rect

    def update(self, dt: float):
        """Update UI state"""
        # Clean up old data
        current_time = time.time()
        cutoff_time = current_time - 300.0  # Keep 5 minutes of data
        
        for device_id in list(self.distance_data.keys()):
            self.distance_data[device_id] = [
                (t, v) for t, v in self.distance_data[device_id] if t > cutoff_time
            ]
            if not self.distance_data[device_id]:
                del self.distance_data[device_id]
                
        for device_id in list(self.volume_data.keys()):
            self.volume_data[device_id] = [
                (t, v) for t, v in self.volume_data[device_id] if t > cutoff_time
            ]
            if not self.volume_data[device_id]:
                del self.volume_data[device_id]

    def cleanup(self):
        """Clean up UI resources"""
        self.add_log_entry("UI Manager cleanup complete")
        print("UI Manager cleanup complete")